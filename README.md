TypeScript-like Compiler in C

This is a simple compiler written in C that mimics a subset of TypeScript. It takes basic variable declarations with simple arithmetic expressions, tokenizes them, parses them into an Abstract Syntax Tree (AST), and then generates bytecode for execution.

How It Works
1. Lexical Analysis (Lexer)
The lexer scans through the source code and breaks it down into tokens. A token represents a single meaningful element, such as keywords (let, function, return), identifiers (like variable names), numbers, or operators (+, -, *, /).

Example:

For the input:

let x = 5 * 3;
The lexer identifies these tokens:

LET
IDENTIFIER(x)
EQUAL
NUMBER(5)
STAR
NUMBER(3)
SEMICOLON

2. Parsing (Parser)

After the lexer generates tokens, the parser takes these tokens and builds an Abstract Syntax Tree (AST). The AST represents the structure of the code and how the expressions and statements are related.
For the input let x = 5 * 3;, the parser generates an AST representing:
A variable declaration (let x =)
A multiplication expression (5 * 3)

3. Bytecode Generation

Once the AST is created, the next step is to generate bytecode. The bytecode is a set of instructions that represents the operations we want to execute.
For the input let x = 5 * 3;, the bytecode might look like:

Load the constant 5
Load the constant 3
Perform the multiplication (MUL)
Store the result in the variable x

Example Code Flow:

let x = 5 * 3;

Tokens Identified:

LET, IDENTIFIER(x), EQUAL, NUMBER(5), STAR, NUMBER(3), SEMICOLON

AST Representation:

Variable Declaration x = (5 * 3)
         VAR_DECL(x)
             |
           BINARY(*)
          /        \
      NUMBER(5)   NUMBER(3)


Generated Bytecode:

LOAD_CONST 5
LOAD_CONST 3
MUL
STORE_VAR x
 
BYTECODE = 0 0 3 5

0: This means "load the constant 5 into memory."
0: This means "load the constant 3 into memory."
3: This means "multiply the two constants (5 and 3)."
5: This means "store the result of the multiplication (which is 15) in a variable called x."


Key Components

Lexer: Breaks the input string into tokens.
Parser: Converts tokens into a hierarchical AST structure.
Bytecode Generator: Converts the AST into bytecode instructions.

Why This is Useful
This compiler demonstrates how a simple programming language can be built from the ground up. It covers the essential stages of compilation: lexical analysis, parsing, and code generation. While this is a simplified example, it lays the foundation for more complex compilers.
